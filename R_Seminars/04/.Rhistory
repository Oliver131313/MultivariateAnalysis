df
data("mpg", package == "ggplot2")
# Ukol 1
library(ggplot2)
library(purrr)
data("mpg", package == "ggplot2")
data("diamonds")
? data
ggplot2::ggplot(mtcars, ggplot2::aes(wt, mpg)) + ggplot2::geom_point()
install.packages
packages()
packageStatus()
packageVersion()
packageVersion("ggplot2")
data("mpg")
data("mpg", package="ggplot2")
library(ggplot2)
data("mpg", package="ggplot2")
mpg
col(mpg)
names(mpg)
? map
? mapply(function, ...)
? map()
map(mean, c(1, 2, 3))
# Ukol 1
totez <- function(x)
x
print(totez(5))
print(totez(c(1, 2, 3)))
# Ukol 2
root <- function(x, n = 2) {
x ^ (1 / n)
}
print(root(16))
# Ukol 3
s <- list(1, 1:2, 1:3, 1:4, 1:5)
#  alebo - zadaj x, aplikuj funkciu tak aby tvoril 1:1, 1:2, 1:3,...
s <- map(1:5, function(x)
, 1:x) # purr
#  alebo - robi to iste co to predtym (. je povolene meno premennej)
s <- map(1:5, ~ 1:.)
v <- map_dbl(s, mean) # map_dbl s balika purr
print(v)
# Ukol 4
Sign <- function(x) {
if (x > 0)
1
else if (x == 0)
0
else
- 1
}
print(Sign(-10))
print(Sign(1))
print(Sign(0))
# Ukol 5
rand_vekt <- map(1:5, ~ runif(10)))
print(rand_vekt)
####################################################################
####################################################################
#                       Hratky s funkcemi
# Ukol 1
vekt <- function(n) {
if (is.numeric(n) && length(n) == 1 && round(n) == n && n > 0)
1:n
else
NA
}
print(vekt(5))
print(vekt(0))
# Ukol 2
nmax <- function(x, n = 1) {
stopifnot(is.numeric(x),
is.numeric(n),
length(n) == 1,
round(n) == n,
n > 0)
sort(unique(x), decreasing = TRUE)[n]
}
print(nmax(1:5, 2))
print(nmax(1:10))
print(nmax(1:10, c(1, 2)))
##################################################################
##################################################################
#                           Iterace
# Ukol 1
library(purrr)
library(ggplot2)
data("mpg", package = "ggplot2")
print(map_chr(mpg, class))
print(map_int(mpg, ~ sum(is.na(.))))
##################################################################
#                       Nemecka picovina
# Ukol 1
testy <- function(o = 50,
so = 30,
pok = 3) {
spravil <- FALSE
n <- 0
while (spravil != 1 && n != pok) {
odpovede <- sample(
x = c(0, 1),
size = o,
prob = c(3 / 4, 1 / 4),
replace = TRUE
)
spravne <- sum(odpovede)
if (spravne < so) {
spravil <- FALSE
n <- n + 1
}
else if (spravne >= so)
spravil <- TRUE
}
return(spravil)
}
# call
S <- 10000
vysledok <- 0
for (s in 1:10000) {
vysledok <- vysledok + testy()
}
freq <- vysledok / S
print(freq)
## Mam to spravne, ale da sa to spravit omnhoo efektivnejsie - UCITELOVO RIESENIE
jeden_test <- function(otazek)
sum(sample(
0:1,
size = otazek,
replace = TRUE,
prob = c(3 / 4, 1 / 4)
))
# pomocí starého replicate()
testy <- function(otazek, opakovani)
max(replicate(opakovani, jeden_test(otazek)))
# totéž pomocí purrr
testy <- function(otazek, opakovani)
max(map_int(seq_len(opakovani), ~ jeden_test(otazek)))
# mean(replicate(1e4, testy(50, 3)) >= 30)  # pomocí starého replicate
freq <- mean(map(1:1e4, ~ testy(50, 3)) >= 30)  # totéž pomocí purrr
print(freq)
# Ukol 2
jeden_test <- function(otazek, pozna)
sum(sample(
0:1,
size = otazek,
replace = TRUE,
prob = c(3 / 4, 1 / 4)
)) +
as.integer(pozna)
# ! Pozor musel som zmenit map_int na map_dbl lebo to robilo problemy !
testy <- function(otazek, opakovani, pozna)
max(map_dbl(seq_len(opakovani), ~ jeden_test(otazek, pozna)))
# Simuluj
pozna_o <- function(otazek, opakovani, pozna, n = 1e4)
mean(map(n, ~ testy(otazek, opakovani, pozna)) >= 30L)
#mean(replicate(n, testy(otazek, opakovani, pozna)) >= 30)
pozna_seq <- 0:50
pozna_p <- map_dbl(pozna_seq, ~ pozna_o(50, 3, .))
plot(pozna_seq, pozna_p, type = "l")
# Ukol 3
print(min(pozna_seq[pozna_p >= 0.05]))
print(min(pozna_seq[pozna_p >= 0.5]))
########################################################################################
#                                   Total Brutal
info_vector <- function(vec, what) {
map(what, vec)
}
? map
map(mean, c(c(1,2,3), c(4, 5,6)))
map(c(c(1,2,3), c(4, 5,6)), ~mean)
map(c(c(1,2,3), c(4, 5,6)), ~mean(.))
map(c(c(1,2,3), c(4, 5,6)), ~c(mean(.), median(.))
pri
map(c(c(1,2,3), c(4, 5,6)), ~c(mean(.), median(.)))
list(mean, median)
f <- list(mean, meadian)
f <- list(mean, median)
map(list, ~.(c(1, 2, 3)))
print(f(vec))
vec <- c(1, 2, 3)
for (f in what){
print(f(vec))
}
what <- list(mean, median)
vec <- c(1, 2, 3)
for (f in what){
print(f(vec))
}
info_vector <- function(vec, what) {
vecout <- c()
for (f in what) {
append(vecout, f(vec))
}
return(vecout)
}
info_vector(c(1, 2, 3), list(mean, median))
what <- list(mean, median)
vec <- c(1, 2, 3)
vecout <- c()
for (f in what){
append(vecout, f(vec))
}
vecout
vec <- c(1, 2, 3)
vecout <- c()
for (f in what){
print(f(vec))
}
what <- list(mean, median)
vec <- c(1, 2, 3)
vecout <- c()
for (f in what){
print(f(vec))
vecout <- c(vecout, vec)
}
vecout
vec <- c(1, 2, 3)
vecout <- c()
for (f in what){
print(f(vec))
vecout <- c(vecout, f(vec))
}
vecout
info_vector <- function(vec, what) {
vecout <- c()
for (f in what) {
vecout <- c(vecout, f(vec))
}
return(vecout)
}
info_vector(c(1, 2, 3), list(mean, median))
map(names(mpg), info_vector(mpg$., what))
map(names(mpg), ~info_vector(mpg$., what))
map(names(mpg), ~info_vector(mpg$x, what))
med_col <- c()
for (col in names(mpg)) {
c(med_col, info_vector(mpg$col, list(median))
}
med_col <- c()
for (col in names(mpg)) {
c(med_col, info_vector(mpg$col, list(median)))
}
med_col
class(mpg$manufacturer)
mpg$manufacturer
class(as.vecto(mpg$manufacturer))
class(as.vector(mpg$manufacturer))
class(c(1, 2, 3))
is.vector(as.vector(mpg$manufacturer))
med_col <- c()
for (col in names(mpg)) {
print(c(med_col, info_vector(mpg$col, list(median))))
}
med_col <- c()
for (col in names(mpg)) {
print(c(med_col, info_vector(mpg$col, list(mean, median))))
}
med_col <- c()
for (col in names(mpg)) {
if (class(mpg$col) == "character")
print(c(med_col, NA))
else
print(c(med_col, info_vector(mpg$col, list(mean, median))))
}
? rep
? dplyr::bind_rows
info <- function(df, ...) {
info_vector <- function(vec, what) {
if (!is.numeric(vec))
return(rep(NA_real_, length(what)))
else
map_dbl(what, ~.(vec))
}
print(map(df, info_vector, what))
what <- list(...)
res <- dplyr::bind_rows(map(df, info_vector, what))
tibble::as_tibble(cbind(stat = names(what), res))
}
print(map(df, info_vector, what))
info_vector <- function(vec, what) {
if (!is.numeric(vec))
return(rep(NA_real_, length(what)))
else
map_dbl(what, ~.(vec))
}
info(mpg, what=list(mean, median, modus))
info(mpg, what=list(mean, median))
View(what)
View(what)
View(mpg)
View(mpg)
drinks
source("C:/Users/kutis/OneDrive/Data Analysis/Alcohol Consumption/drinks_PCA.R", echo=TRUE)
setwd("C:/Users/kutis/OneDrive/Data Analysis/Alcohol Consumption")
source("C:/Users/kutis/OneDrive/Data Analysis/Alcohol Consumption/drinks_PCA.R", echo=TRUE)
drinks[sort(drinks$beer_servings, decreasing = TRUE)]
drinks[sort(drinks$beer_servings, decreasing = TRUE), ]
drinks$beer_servings
drinks[sort(drinks$beer_servings, decreasing = FALSE), ]
duplicated(drinks)
View(drinks)
View(drinks)
order(drinks$beer_servings, decreasing = TRUE)
drinks
drinks[order(drinks$beer_servings, decreasing = TRUE), ]
p <- prcomp(x = drinks, scale. = TRUE, center = T)
is.na(drinks)
p <- prcomp(x = drinks.T, scale. = TRUE, center = T)
p <- prcomp(x = t(drinks), scale. = TRUE, center = T)
p <- prcomp(drinks, scale. = TRUE, center = T)
summary(drinks)
p <- prcomp(drinks[, 2:], scale. = TRUE, center = T)
p <- prcomp(x=drinks[, 2:], scale. = TRUE, center = T)
drinks[, 2:]
drinks[, 2:-1]
drinks[, 2:5]
p <- prcomp(x=drinks[, 2:5], scale. = TRUE, center = T)
p$rotation
p$sdev^2
p$sdev^2 / sum(p$sdev^2)
plot(var_pct)
var_pct <- p$sdev^2 / sum(p$sdev^2)
plot(var_pct)
plot(var_pct, type = "l")
p$rotation * p$sdev
matrix(rep(p$sdev, 4), 4, 4, byrow=TRUE)
p$rotation * v
p$rotation * v
source("C:/Users/kutis/OneDrive/Data Analysis/Alcohol Consumption/drinks_PCA.R", echo=TRUE)
p$rotation * t(p$sdev)
t(p$sdev)
p$sdev
rep(p$sdev, 4)
matrix(p$sdev), 4, 4, byrow=TRUE)
matrix(p$sdev, 4, 4, byrow=TRUE)
# Loadings
p$rotation / v
ggbiplot(p, scale=1)
library(ggbiplot)
ggbiplot(p, scale=1)
biplot(p,xlim=c(-1,1))
library(DescTools)
library(ellipse)
library(car)
x <- cor(Satisfaction, use = "pairwise.complete.obs")
pairs(Satisfaction, panel = panel.smooth)
scatterplotMatrix(
Satisfaction,
smooth = F,
diagonal = "histogram",
col = c(2, 1, 4)
)
PlotCorr(x)
plotcorr(x)
load('Satisfaction.RData')
setwd("C:/Users/kutis/OneDrive/School/1. Semester/Vicerozmerne statisticke metody/Podklady k cvicenim/R/04")
source("C:/Users/kutis/OneDrive/School/1. Semester/Vicerozmerne statisticke metody/Podklady k cvicenim/R/04/04_c.R", echo=TRUE)
# 2 - Determine number of factors
p <- prcomp(x = x, scale. = TRUE, center = T)
p.var.expl <- p$sdev^2 / sum(p$sdev^2)
plot(p.var.expl, type="l")
print("Looks like k = 3 is the optimal number of factors.")
print("#2 -> Looks like k = 3 is the optimal number of factors.")
print("#2 Looks like k = 3 is the optimal number of factors.")
print(p.var.expl)
p$sdev^2 / sum(p$sdev^2)
sum(p$sdev^2)
p$sdev^2
p.var.expl <- p$sdev^2 / sum(p$sdev^2) *100
print(p.var.expl)
print(sum(p.var.expl[1:3, ]))
print(sum(p.var.expl[1:3]))
print('#2 k = 3 explains' + str(sum(p.var.expl[1:3])) + 'of variance.')
print('#2 k = 3 explains' + as.character(sum(p.var.expl[1:3])) + 'of variance.')
library(stringr)
print(str_glue('#2 k = 3 explains {k.var} of variance.', k.var = as.character(sum(p.var.expl[1:3]))
))
print(str_glue('#2 k = 3 explains {k.var}% of variance.', k.var = round(as.character(sum(p.var.expl[1:3]), 2)
))
print(str_glue('#2 k = 3 explains {k.var}% of variance.',
k.var = round(as.character(sum(
p.var.expl[1:3]
), 2))))
print(str_glue('#2 k = 3 explains {k.var}% of variance.',
k.var = round(as.character(sum(
p.var.expl[1:3]
)), 2)))
print(str_glue('#2 k = 3 explains {k.var}% of variance.',
k.var = as.character(round(sum(p.var.expl[1:3])))
)
)
source("C:/Users/kutis/OneDrive/School/1. Semester/Vicerozmerne statisticke metody/Podklady k cvicenim/R/04/04_c.R", echo=TRUE)
print(str_glue('#2 k = 2 explains {k.var}% of variance.',
k.var = as.character(round(sum(
p.var.expl[1:2]
)))))
print('#2 We will use k=2 factors.')
print("#2 Looks like k = 3 is the optimal number of factors.")
print(str_glue('#2 k = 3 explains {k.var}% of variance.',
k.var = as.character(round(sum(
p.var.expl[1:3]
)))))
print(str_glue('#2 k = 2 explains {k.var}% of variance.',
k.var = as.character(round(sum(
p.var.expl[1:2]
)))))
print('#2 We will use k=2 factors.')
# 4 - Factor Analysis from psych package
library(psych)
install.packages("psych")
# 4 - Factor Analysis from psych package
library(psych)
# 3 - Determine number of factors
p <- prcomp(x = x, scale. = TRUE, center = TRUE)
# Varimax rotation, Maximum Likelihood method for extraction
f1 <-
fa(
r = x,
nfactors = 2,
rotate = "varimax",
fm = "ml",
scores = "regression",
residuals = TRUE
)
f1$e.values
sum(f1$e.values)
f1
# Jednotlive premenne v novom lin. systeme
f1$fit
# Jednotlive premenne v novom lin. systeme
f1$factors
? fa
# Jednotlive premenne v novom lin. systeme
f1$loadings
f1$Structure
# Jednotlive premenne v novom lin. systeme
f1$scores
# Jednotlive premenne v novom lin. systeme
f1$score.cor
# Jednotlive premenne v novom lin. systeme
f1
plot(f1)
plot(f2)
# 6
plot(f1)
plot(f2)
# 5 Jednotlive premenne v novom lin. systeme
f1$loadings
# clear workspace
rm(list = ls())
source("C:/Users/kutis/OneDrive/School/1. Semester/Vicerozmerne statisticke metody/Podklady k cvicenim/R/04/04_c.R", echo=TRUE)
# 7 - Interpretacie pre komunality AtWork1
print(f1[1, ])
f1
f1$loadings
# 7 - Interpretacie pre komunality AtWork1
print(f1$weights)
? fa
# 7 - Interpretacie pre komunality AtWork1
print(f1$Structure)
# 7 - Interpretacie pre komunality AtWork1
print(f1$Structure[1])
# 7 - Interpretacie pre komunality AtWork1
print(f1$communality)
# 7 - Interpretacie pre komunality AtWork1
print(f1$communalities)
# 7 - Interpretacie pre komunality AtWork1
print(f1$=fit.off)
# 7 - Interpretacie pre komunality AtWork1
print(f1$fit.off)
# 7 - Interpretacie pre komunality AtWork1
print(f1$residual)
# 7 - Interpretacie pre komunality AtWork1
print(f1$r.scores)
# 7 - Interpretacie pre komunality AtWork1
print(f1$weights)
# 7 - Interpretacie pre komunality AtWork1
print(f1$scores)
# 7 - Interpretacie pre komunality AtWork1
print(f1$score.cor)
# 7 - Interpretacie pre komunality AtWork1
print(f1$rot.mat)
# 7 - Interpretacie pre komunality AtWork1
print(f1$r.scores)
# 7 - Interpretacie pre komunality AtWork1
print(f1$values)
# 7 - Interpretacie pre komunality AtWork1
print(f1)
print("At work comm.: 57% variability je vysvetlenych k=2 faktormi.\\
Zvysok je unique pre tuto premennu")
print("At work comm.: 57% variability je vysvetlenych k=2 faktormi.\
Zvysok je unique pre tuto premennu")
print("At work comm.: 57% variability je vysvetlenych k=2 faktormi.
Zvysok je unique pre tuto premennu")
print("At work comm.: 57% variability je vysvetlenych k=2 faktormi."\\
"Zvysok je unique pre tuto premennu")
print("At work comm.: 57% variability je vysvetlenych k=2 faktormi."\
"Zvysok je unique pre tuto premennu")
print("At work comm.: 57% variability je vysvetlenych k=2 faktormi."//
"Zvysok je unique pre tuto premennu")
print("At work comm.: 57% variability je vysvetlenych k=2 faktormi." +
"Zvysok je unique pre tuto premennu")
source("C:/Users/kutis/OneDrive/School/1. Semester/Vicerozmerne statisticke metody/Podklady k cvicenim/R/04/04_c.R")
source("C:/Users/kutis/OneDrive/School/1. Semester/Vicerozmerne statisticke metody/Podklady k cvicenim/R/04/04_c.R")
# 8
f1$residual
print("Vypada to, ze mimo diagonaly nepozorujeme vela hodnot rozdielnych od nuly! To naznacuje, ze model replikuje povodnu kov. maticu dobre.")
print("NIE JE potrebne pridavat dalsi faktor.")
# 9 - Koeficienty skore
f1$weights
